var documenterSearchIndex = {"docs":
[{"location":"download_buildings/#Download-OpenStreetMap-Buildings","page":"Download OpenStreetMap Buildings","title":"Download OpenStreetMap Buildings","text":"","category":"section"},{"location":"download_buildings/","page":"Download OpenStreetMap Buildings","title":"Download OpenStreetMap Buildings","text":"download_osm_buildings\nLightOSM.osm_buildings_from_place_name\nLightOSM.osm_buildings_from_point\nLightOSM.osm_buildings_from_bbox","category":"page"},{"location":"download_buildings/#LightOSM.download_osm_buildings","page":"Download OpenStreetMap Buildings","title":"LightOSM.download_osm_buildings","text":"download_osm_buildings(download_method::Symbol;\n                       metadata::Bool=false,\n                       download_format::Symbol=:osm,\n                       save_to_file_location::Union{String,Nothing}=nothing,\n                       download_kwargs...\n                       )::Union{XMLDocument,Dict{String,Any}}\n\nDownloads OpenStreetMap buildings data by querying with a place name, bounding box, or centroid point.\n\nArguments\n\ndownload_method::Symbol: Download method, choose from :place_name, :bbox or :point.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\nsave_to_file_location::Union{String,Nothing}=nothing: Specify a file location to save downloaded data to disk.\n\nRequired Download Kwargs\n\ndownload_method=:place_name\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\n\ndownload_method=:bbox\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\n\ndownload_method=:point\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\n\nReturn\n\nUnion{XMLDocument,Dict{String,Any}}: OpenStreetMap buildings data parsed as either XML or Dictionary object depending on the download method.\n\n\n\n\n\n","category":"function"},{"location":"download_buildings/#LightOSM.osm_buildings_from_place_name","page":"Download OpenStreetMap Buildings","title":"LightOSM.osm_buildings_from_place_name","text":"osm_buildings_from_place_name(;place_name::String,\n                            metadata::Bool=false,\n                            download_format::Symbol=:osm\n                            )::String\n\nDownloads OpenStreetMap buildings using any place name string.\n\nArguments\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap buildings data response string.\n\n\n\n\n\n","category":"function"},{"location":"download_buildings/#LightOSM.osm_buildings_from_point","page":"Download OpenStreetMap Buildings","title":"LightOSM.osm_buildings_from_point","text":"osm_buildings_from_point(;point::GeoLocation,\n                       radius::Number,\n                       metadata::Bool=false,\n                       download_format::Symbol=:osm\n                       )::String\n\nDownloads OpenStreetMap buildings using bounding box coordinates calculated from a centroid point and radius (km).\n\nArguments\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap buildings data response string.\n\n\n\n\n\n","category":"function"},{"location":"download_buildings/#LightOSM.osm_buildings_from_bbox","page":"Download OpenStreetMap Buildings","title":"LightOSM.osm_buildings_from_bbox","text":"osm_buildings_from_bbox(;minlat::AbstractFloat,\n                      minlon::AbstractFloat,\n                      maxlat::AbstractFloat,\n                      maxlon::AbstractFloat,\n                      metadata::Bool=false,\n                      download_format::Symbol=:osm\n                      )::String\n\nDownloads OpenStreetMap buildings using bounding box coordinates.\n\nArguments\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap buildings data response string.\n\n\n\n\n\n","category":"function"},{"location":"create_graph/#Create-[OSMGraph](@ref)-Object","page":"Create OSMGraph Object","title":"Create OSMGraph Object","text":"","category":"section"},{"location":"create_graph/","page":"Create OSMGraph Object","title":"Create OSMGraph Object","text":"graph_from_object\ngraph_from_download\ngraph_from_file","category":"page"},{"location":"create_graph/#LightOSM.graph_from_object","page":"Create OSMGraph Object","title":"LightOSM.graph_from_object","text":"graph_from_object(osm_data_object::Union{XMLDocument,Dict};\n                  network_type::Symbol=:drive,\n                  weight_type::Symbol=:time,\n                  graph_type::Symbol=:static,\n                  precompute_dijkstra_states::Bool=false,\n                  largest_connected_component::Bool=true\n                  )::OSMGraph\n\nCreates an OSMGraph object from download OpenStreetMap network data, use with download_osm_network.\n\nArguments\n\nosm_data_object::Symbol: OpenStreetMap network data parsed as either XML or Dictionary object depending on the download method.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail, must match the network type used to download osm_data_object.\nweight_type::Symbol=:time: Weight type for graph edges, pick from :distance (km), :time (hours), :lane_efficiency (time scaled by number of lanes). \ngraph_type::Symbol=:static: Type of Graphs.AbstractGraph, pick from :static (StaticDiGraph), :light (DiGraph), :simple_weighted (SimpleWeightedDiGraph), :meta (MetaDiGraph).\nprecompute_dijkstra_states::Bool=false: Set true to precompute dijkstra parent states for every source node in the graph, NOTE this may take a while and may not be possible for graphs with large amount of nodes due to memory limits.\nlargest_connected_component::Bool=true: Set true to keep only the largest connected components in the network.\n\nReturn\n\nOSMGraph: Container for storing OpenStreetMap node, way, relation and graph related obejcts.\n\n\n\n\n\n","category":"function"},{"location":"create_graph/#LightOSM.graph_from_download","page":"Create OSMGraph Object","title":"LightOSM.graph_from_download","text":"graph_from_download(download_method::Symbol;\n                    network_type::Symbol=:drive,\n                    metadata::Bool=false,\n                    download_format::Symbol=:json,\n                    save_to_file_location::Union{String,Nothing}=nothing,\n                    weight_type::Symbol=:time,\n                    graph_type::Symbol=:static,\n                    precompute_dijkstra_states::Bool=false,\n                    largest_connected_component::Bool=true,\n                    download_kwargs...\n                    )::OSMGraph\n\nDownloads OpenStreetMap network data and creates an OSMGraph object.\n\nArguments\n\ndownload_method::Symbol: Download method, choose from :place_name, :bbox or :point.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:json: Download format, either :osm, :xml or json.\nsave_to_file_location::Union{String,Nothing}=nothing: Specify a file location to save downloaded data to disk.\nweight_type::Symbol=:time: Weight type for graph edges, pick from :distance (km), :time (hours), :lane_efficiency (time scaled by number of lanes). \ngraph_type::Symbol=:static: Type of Graphs.AbstractGraph, pick from :static (StaticDiGraph), :light (DiGraph), :simple_weighted (SimpleWeightedDiGraph), :meta (MetaDiGraph).\nprecompute_dijkstra_states::Bool=false: Set true to precompute dijkstra parent states for every source node in the graph, NOTE this may take a while and may not be possible for graphs with large amount of nodes due to memory limits.\nlargest_connected_component::Bool=true: Set true to keep only the largest connected components in the network.\n\nRequired Kwargs for each Download Method\n\ndownload_method=:place_name\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\n\ndownload_method=:bbox\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\n\ndownload_method=:point\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\n\ndownload_method=:polygon\n\npolygon::AbstractVector: Vector of longitude-latitude pairs.\n\nNetwork Types\n\n:drive: Motorways excluding private and service ways.\n:drive_service: Motorways including private and service ways.\n:walk: Walkways only.\n:bike: Cycleways only.\n:all: All motorways, walkways and cycleways excluding private ways.\n:all_private: All motorways, walkways and cycleways including private ways.\n:none: No network filters.\n:rail: Railways excluding proposed and platform.\n\nReturn\n\nOSMGraph: Container for storing OpenStreetMap node, way, relation and graph related obejcts.\n\n\n\n\n\n","category":"function"},{"location":"create_graph/#LightOSM.graph_from_file","page":"Create OSMGraph Object","title":"LightOSM.graph_from_file","text":"graph_from_object(file_path::String;\n                  network_type::Symbol=:drive,\n                  weight_type::Symbol=:time,\n                  graph_type::Symbol=:static,\n                  precompute_dijkstra_states::Bool=false,\n                  largest_connected_component::Bool=true\n                  )::OSMGraph\n\nCreates an OSMGraph object from a downloaded OpenStreetMap network data file, the extention must be either .json, .osm or .xml.\n\nArguments\n\nfile_path::String: OpenStreetMap network data file location.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail, must match the network type used to download osm_data_object.\nweight_type::Symbol=:time: Weight type for graph edges, pick from :distance (km), :time (hours), :lane_efficiency (time scaled by number of lanes). \ngraph_type::Symbol=:static: Type of Graphs.AbstractGraph, pick from :static (StaticDiGraph), :light (DiGraph), :simple_weighted (SimpleWeightedDiGraph), :meta (MetaDiGraph).\nprecompute_dijkstra_states::Bool=false: Set true to precompute dijkstra parent states for every source node in the graph, NOTE this may take a while and may not be possible for graphs with large amount of nodes due to memory limits.\nlargest_connected_component::Bool=true: Set true to keep only the largest connected components in the network.\n\nReturn\n\nOSMGraph: Container for storing OpenStreetMap node, way, relation and graph related obejcts.\n\n\n\n\n\n","category":"function"},{"location":"testing_use/#Using-LightOSM-in-Unit-Tests","page":"Unit Test Use","title":"Using LightOSM in Unit Tests","text":"","category":"section"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"To avoid having to download graphs within unit tests, it is suggested that something similar to the OSMGraph stub used in LightOSM's own tests (see test/stub.jl) is used by your package. This allows you to have explicit control over the structure of the graph and therefore to have explicit tests.","category":"page"},{"location":"testing_use/#Manual-Stub-Creation","page":"Unit Test Use","title":"Manual Stub Creation","text":"","category":"section"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"To create your own graph stub, the nodes and ways must be manually created and inputted. Restrictions can also be optionally added.","category":"page"},{"location":"testing_use/#Nodes","page":"Unit Test Use","title":"Nodes","text":"","category":"section"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"Nodes must be have an ID and GeoLocation","category":"page"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"lats = [-38.0751637, -38.0752637, -38.0753637, -38.0754637]\nlons = [145.3326838, 145.3326838, 145.3326838, 145.3326833]\nnode_ids = [1001, 1002, 1003, 1004]\nnodes = Dict(\n    id => Node(\n        id,\n        GeoLocation(lat, lon),\n        Dict{String, Any}() # Don't need tags\n    ) for (lat, lon, id) in zip(lats, lons, node_ids)\n)","category":"page"},{"location":"testing_use/#Ways","page":"Unit Test Use","title":"Ways","text":"","category":"section"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"Ways must have an ID, a node list that only includes nodes you have defined and must include the tags in the example shown below.","category":"page"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"way_ids = [2001, 2002]\nway_nodes = [\n    [1001, 1002, 1003],\n    [1003, 1004],\n]\ntag_dicts = [\n    Dict{String, Any}(\n        \"oneway\" => false,\n        \"reverseway\" => false,\n        \"maxspeed\" => Int16(50),\n        \"lanes\" => Int8(2)\n    ),\n    Dict{String, Any}(\n        \"oneway\" => false,\n        \"reverseway\" => false,\n        \"maxspeed\" => Int16(50),\n        \"lanes\" => Int8(2)\n    ),\n]\nways = Dict(way_id => Way(way_id, nodes, tag_dict) for (way_id, nodes, tag_dict) in zip(way_ids, way_nodes, tag_dicts))","category":"page"},{"location":"testing_use/#Graph-creation","page":"Unit Test Use","title":"Graph creation","text":"","category":"section"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"warning: Warning\nThe functions here are not part of the stable API and will be replaced by a generate_graph function or similar","category":"page"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"Creating the graph relies on some LightOSM internals to populate all other fields of the OSMGraph object","category":"page"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"U = LightOSM.DEFAULT_OSM_INDEX_TYPE\nT = LightOSM.DEFAULT_OSM_ID_TYPE\nW = LightOSM.DEFAULT_OSM_EDGE_WEIGHT_TYPE\ng = OSMGraph{U,T,W}(nodes=nodes, ways=ways)\nLightOSM.add_node_and_edge_mappings!(g)\nLightOSM.add_weights!(g, :distance) # or :time\nLightOSM.add_graph!(g, :static) # or any desired graph type\nLightOSM.add_node_tags!(g)\ng.dijkstra_states = Vector{Vector{U}}(undef, length(g.nodes))\nLightOSM.add_kdtree!(g)","category":"page"},{"location":"testing_use/#Restrictions","page":"Unit Test Use","title":"Restrictions","text":"","category":"section"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"Optionally, restrictions can be added.","category":"page"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"restriction1 = Restriction(\n    3001,\n    \"via_node\",\n    Dict{String, Any}(\"restriction\"=>\"only_straight_on\",\"type\"=>\"restriction\"),\n    2001,\n    2002,\n    1003, # must be set if restriction is via_node\n    nothing, # must be set if restriction is via_way\n    false, # true for no_left_turn, no_right_turn, no_u_turn, no_straight_on\n    true # true for only_right_turn, only_left_turn, only_straight_on\n)\nrestrictions = Dict(restriction1.id => restriction1)","category":"page"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"See Restriction for more information on Restriction objects.","category":"page"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"And then when instantiating the OSMGraph","category":"page"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"g = OSMGraph{U,T,W}(nodes=nodes, ways=ways, restrictions=restrictions)\nLightOSM.add_indexed_restrictions!(g)","category":"page"},{"location":"testing_use/#Using-the-LightOSM-stub","page":"Unit Test Use","title":"Using the LightOSM stub","text":"","category":"section"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"danger: This is not part of the API\nUsing this function is not part of the packages API, and thereore may change without respecting Semantic Versioning. It is suggested to create your own stub for your own package, rather than using this.","category":"page"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"To use the stub provided in LightOSM, run the following in your tests","category":"page"},{"location":"testing_use/","page":"Unit Test Use","title":"Unit Test Use","text":"using LightOSM\ninclude(joinpath(pathof(LightOSM), \"test\", \"stub.jl\"))\ng = basic_osm_graph_stub()","category":"page"},{"location":"create_buildings/#Create-[Building](@ref)-Objects","page":"Create Building Objects","title":"Create Building Objects","text":"","category":"section"},{"location":"create_buildings/","page":"Create Building Objects","title":"Create Building Objects","text":"buildings_from_object\nbuildings_from_download\nbuildings_from_file","category":"page"},{"location":"create_buildings/#LightOSM.buildings_from_object","page":"Create Building Objects","title":"LightOSM.buildings_from_object","text":"buildings_from_object(buildings_xml_object::XMLDocument)::Dict{Integer,Building}\n\nCreates Building objects from data downloaded with download_osm_buildings.\n\nArguments\n\nbuildings_xml_object::XMLDocument: Buildings data downloaded in :xml or :osm format.\n\nReturn\n\nDict{Integer,Building}: Mapping from building relation/way ids to Building objects.\n\n\n\n\n\nbuildings_from_object(buildings_json_object::AbstractDict)::Dict{Integer,Building}\n\nCreates Building objects from data downloaded with download_osm_buildings.\n\nArguments\n\nbuildings_json_object::AbstractDict: Buildings data downloaded in :json format.\n\nReturn\n\nDict{Integer,Building}: Mapping from building relation/way ids to Building objects.\n\n\n\n\n\n","category":"function"},{"location":"create_buildings/#LightOSM.buildings_from_download","page":"Create Building Objects","title":"LightOSM.buildings_from_download","text":"buildings_from_download(download_method::Symbol;\n                        metadata::Bool=false,\n                        download_format::Symbol=:osm,\n                        save_to_file_location::Union{String,Nothing}=nothing,\n                        download_kwargs...\n                        )::Dict{Integer,Building}\n\nDownloads and Creates Building objects from OpenStreetMap APIs.\n\nArguments\n\ndownload_method::Symbol: Download method, choose from :place_name, :bbox or :point.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\nsave_to_file_location::Union{String,Nothing}=nothing: Specify a file location to save downloaded data to disk.\n\nRequired Download Kwargs\n\ndownload_method=:place_name\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\n\ndownload_method=:bbox\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\n\ndownload_method=:point\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\n\nReturn\n\nDict{Integer,Building}: Mapping from building relation/way ids to Building objects.\n\n\n\n\n\n","category":"function"},{"location":"create_buildings/#LightOSM.buildings_from_file","page":"Create Building Objects","title":"LightOSM.buildings_from_file","text":"buildings_from_file(file_path::String)::Dict{Integer,Building}\n\nCreates Building objects from OpenStreetMap data file (either :osm, :xml or :json format).\n\nArguments\n\nfile_path::String: Path to OpenStreetMap data file.\n\nReturn\n\nDict{Integer,Building}: Mapping from building relation/way ids to Building objects.\n\n\n\n\n\n","category":"function"},{"location":"geolocation/#[GeoLocation](@ref)-Methods","page":"GeoLocation Methods","title":"GeoLocation Methods","text":"","category":"section"},{"location":"geolocation/","page":"GeoLocation Methods","title":"GeoLocation Methods","text":"distance\nheading\ncalculate_location\nLightOSM.to_cartesian\nLightOSM.bounding_box_from_point","category":"page"},{"location":"geolocation/#LightOSM.distance","page":"GeoLocation Methods","title":"LightOSM.distance","text":"distance(A::Union{Vector{GeoLocation}, GeoLocation, Vector{<:Node}, Node, Vector{<:AbstractFloat}},\n         B::Union{Vector{GeoLocation}, GeoLocation, Vector{<:Node}, Node, Vector{<:AbstractFloat}},\n         type::Symbol=:haversine\n         )\n\nCalculates the distance (km) between two points or two vectors of points.\n\nArguments\n\nA::Union{Vector{GeoLocation}, GeoLocation, Vector{<:Node}, Node, Vector{<:AbstractFloat}}: Vector of origin points.\nB::Union{Vector{GeoLocation}, GeoLocation, Vector{<:Node}, Node, Vector{<:AbstractFloat}}: Vector of destination points.\nmethod::Symbol=:haversine: Either :haversine or :euclidean.\n\nReturn\n\nDistance between origin and destination points in km.\n\n\n\n\n\n","category":"function"},{"location":"geolocation/#LightOSM.heading","page":"GeoLocation Methods","title":"LightOSM.heading","text":"heading(a::GeoLocation, b::GeoLocation, return_units::Symbol=:degrees)\nheading(a::Node, b::Node, return_units::Symbol=:degrees)\nheading(A::Vector{GeoLocation}, B::Vector{GeoLocation}, return_units::Symbol=:degrees)\nheading(A::Vector{Node}, B::Vector{Node}, return_units::Symbol=:degrees)\n\nCalculates heading(s) / bearing(s) between two points (a is origin, b is destination) or two vectors of points (A is vector of origins, B is vector of destinations). Points can be either GeoLocations or Nodes.\n\nDepending on the return_units chosen, the return angle is in range of [-π, π] if :radians or [-180, 180] if :degrees. Additionally, adjusts destination longitude in case the straight line path between a and b crosses the International Date Line.\n\n\n\n\n\n","category":"function"},{"location":"geolocation/#LightOSM.calculate_location","page":"GeoLocation Methods","title":"LightOSM.calculate_location","text":"calculate_location(origin::GeoLocation, heading::Number, distance::Number)\ncalculate_location(origin::Node, heading::Number, distance::Number)\ncalculate_location(origin::Vector{GeoLocation}, heading::Vector{<:Number}, distance::Vector{<:Number})\ncalculate_location(origin::Vector{Node}, heading::Vector{<:Number}, distance::Vector{<:Number})\n\nCalculates next location(s) given origin GeoLocation(s) or Node(s), heading(s) (degrees) and distance(s) (km).\n\nLocations are returned as GeoLocations.\n\n\n\n\n\n","category":"function"},{"location":"geolocation/#LightOSM.to_cartesian","page":"GeoLocation Methods","title":"LightOSM.to_cartesian","text":"to_cartesian(lat::T, lon::T, r::T) where {T} \nto_cartesian(location::GeoLocation)\nto_cartesian(locations::Vector{GeoLocation})\n\nConverts a vector of GeoLocations to (x, y, z) cartesian coordinates (based on radius of the Earth).\n\n\n\n\n\n","category":"function"},{"location":"geolocation/#LightOSM.bounding_box_from_point","page":"GeoLocation Methods","title":"LightOSM.bounding_box_from_point","text":"bounding_box_from_point(point::GeoLocation, radius::Number)::NamedTuple\n\nCalculates the coordinates of the bounding box given a centroid point and radius (km).\n\nArguments\n\npoint::GeoLocation: Centroid of the bounding box as an GeoLocation.\nradius::Number: Radius in km of the bounding box (to each corner).\n\nReturn\n\nNamedTuple: Named tuple with attributes minlat, minlon, maxlat, right_lon.\n\n\n\n\n\n","category":"function"},{"location":"nearest_node/#Nearest-Node","page":"Nearest Node","title":"Nearest Node","text":"","category":"section"},{"location":"nearest_node/","page":"Nearest Node","title":"Nearest Node","text":"nearest_node","category":"page"},{"location":"nearest_node/#LightOSM.nearest_node","page":"Nearest Node","title":"LightOSM.nearest_node","text":"nearest_node(g::OSMGraph, point::GeoLocation)\nnearest_node(g::OSMGraph, points::Vector{GeoLocation})\nnearest_node(g::OSMGraph, point::AbstractVector{<:AbstractFloat})\nnearest_node(g::OSMGraph, points::AbstractVector{<:AbstractVector{<:AbstractFloat}})\n\nFinds the nearest node from a point (specified by a GeoLocation or set of Latitude Longitude coordinates) or Vector of points using a NearestNeighbors.jl KDTree.\n\nArguments\n\ng::OSMGraph: Graph container.\npoint/points: Single point as a GeoLocation or [lat, lon, alt], or a Vector of such points\n\nReturn\n\nTuple of neighbours and straight line euclidean distances from each point ([neighbours...], [dists...]).   Tuple elements are Vectors if a Vector of points is inputted, and numbers if a single point is inputted.\n\n\n\n\n\nnearest_node(g::OSMGraph, node::Node)\nnearest_node(g::OSMGraph, nodes::Vector{<:Node})\nnearest_node(g::OSMGraph, node_ids::AbstractVector{<:Integer})\nnearest_node(g::OSMGraph, node_id::Integer)\n\nFinds the nearest node from a node (specified by the Node object or node id) or Vector of nodes using a NearestNeighbors.jl KDTree. The origin node itself is not included in the results.\n\nArguments\n\ng::OSMGraph: Graph container.\nnode/nodes/node_id/node_ids: Single node or Vector of nodes specified by Node objects or id.\n\nReturn\n\nTuple of neighbours and straight line euclidean distances from each node ([neighbours...], [dists...]).   Tuple elements are Vectorsif a Vector of nodes is inputted, and numbers if a single point is inputted.\n\n\n\n\n\n","category":"function"},{"location":"graph_utilities/#[Graph-Utilities](@ref)-Methods","page":"Graph Utilities Methods","title":"Graph Utilities Methods","text":"","category":"section"},{"location":"graph_utilities/","page":"Graph Utilities Methods","title":"Graph Utilities Methods","text":"index_to_node_id\nindex_to_node\nnode_id_to_index\nnode_to_index\nindex_to_dijkstra_state\nnode_id_to_dijkstra_state\nset_dijkstra_state_with_index!\nset_dijkstra_state_with_node_id!\nmaxspeed_from_index","category":"page"},{"location":"graph_utilities/#LightOSM.index_to_node_id","page":"Graph Utilities Methods","title":"LightOSM.index_to_node_id","text":"index_to_node_id(g::OSMGraph, x::Integer)\nindex_to_node_id(g::OSMGraph, x::Vector{<:Integer})\n\nMaps node index to node id.\n\n\n\n\n\n","category":"function"},{"location":"graph_utilities/#LightOSM.index_to_node","page":"Graph Utilities Methods","title":"LightOSM.index_to_node","text":"index_to_node(g::OSMGraph, x::Integer)\nindex_to_node(g::OSMGraph, x::Vector{<:Integer})\n\nMaps node index to node object.\n\n\n\n\n\n","category":"function"},{"location":"graph_utilities/#LightOSM.node_id_to_index","page":"Graph Utilities Methods","title":"LightOSM.node_id_to_index","text":"node_id_to_index(g::OSMGraph, x::Integer)\nnode_id_to_index(g::OSMGraph, x::Vector{<:Integer})\n\nMaps node id to index.\n\n\n\n\n\n","category":"function"},{"location":"graph_utilities/#LightOSM.node_to_index","page":"Graph Utilities Methods","title":"LightOSM.node_to_index","text":"node_to_index(g::OSMGraph, x::Node)\nnode_to_index(g::OSMGraph, x::Vector{Node})\n\nMaps node object to index.\n\n\n\n\n\n","category":"function"},{"location":"graph_utilities/#LightOSM.index_to_dijkstra_state","page":"Graph Utilities Methods","title":"LightOSM.index_to_dijkstra_state","text":"index_to_dijkstra_state(g::OSMGraph, x::Integer)\n\nMaps node index to dijkstra state (parents).\n\n\n\n\n\n","category":"function"},{"location":"graph_utilities/#LightOSM.node_id_to_dijkstra_state","page":"Graph Utilities Methods","title":"LightOSM.node_id_to_dijkstra_state","text":"node_id_to_dijkstra_state(g::OSMGraph, x::Integer)\n\nMaps node id to dijkstra state (parents).\n\n\n\n\n\n","category":"function"},{"location":"graph_utilities/#LightOSM.set_dijkstra_state_with_index!","page":"Graph Utilities Methods","title":"LightOSM.set_dijkstra_state_with_index!","text":"set_dijkstra_state_with_index!(g::OSMGraph, index::Integer, state)\n\nSet dijkstra state (parents) with node index.\n\n\n\n\n\n","category":"function"},{"location":"graph_utilities/#LightOSM.set_dijkstra_state_with_node_id!","page":"Graph Utilities Methods","title":"LightOSM.set_dijkstra_state_with_node_id!","text":"set_dijkstra_state_with_node_id!(g::OSMGraph, index::Integer, state)\n\nSet dijkstra state (parents) with node id.\n\n\n\n\n\n","category":"function"},{"location":"graph_utilities/#LightOSM.maxspeed_from_index","page":"Graph Utilities Methods","title":"LightOSM.maxspeed_from_index","text":"maxspeed_from_index(g, x::Integer)\nmaxspeed_from_node_id(g, x::Integer)\n\nGet maxspeed from index id or node id.\n\n\n\n\n\n","category":"function"},{"location":"download_network/#Download-OpenStreetMap-Network","page":"Download OpenStreetMap Network","title":"Download OpenStreetMap Network","text":"","category":"section"},{"location":"download_network/","page":"Download OpenStreetMap Network","title":"Download OpenStreetMap Network","text":"download_osm_network\nLightOSM.osm_network_from_place_name\nLightOSM.osm_network_from_point\nLightOSM.osm_network_from_bbox\nLightOSM.osm_network_from_polygon","category":"page"},{"location":"download_network/#LightOSM.download_osm_network","page":"Download OpenStreetMap Network","title":"LightOSM.download_osm_network","text":"download_osm_network(download_method::Symbol;\n                     network_type::Symbol=:drive,\n                     metadata::Bool=false,\n                     download_format::Symbol=:json,\n                     save_to_file_location::Union{String,Nothing}=nothing,\n                     download_kwargs...\n                     )::Union{XMLDocument,Dict{String,Any}}\n\nDownloads an OpenStreetMap network by querying with a place name, bounding box, or centroid point.\n\nArguments\n\ndownload_method::Symbol: Download method, choose from :place_name, :bbox or :point.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:json: Download format, either :osm, :xml or json.\nsave_to_file_location::Union{String,Nothing}=nothing: Specify a file location to save downloaded data to disk.\n\nRequired Kwargs for each Download Method\n\ndownload_method=:place_name\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\n\ndownload_method=:bbox\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\n\ndownload_method=:point\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\n\ndownload_method=:polygon\n\npolygon::AbstractVector: Vector of longitude-latitude pairs.\n\nNetwork Types\n\n:drive: Motorways excluding private and service ways.\n:drive_service: Motorways including private and service ways.\n:walk: Walkways only.\n:bike: Cycleways only.\n:all: All motorways, walkways and cycleways excluding private ways.\n:all_private: All motorways, walkways and cycleways including private ways.\n:none: No network filters.\n:rail: Railways excluding proposed and platform.\n\nReturn\n\nUnion{XMLDocument,Dict{String,Any}}: OpenStreetMap network data parsed as either XML or Dictionary object depending on the download method.\n\n\n\n\n\n","category":"function"},{"location":"download_network/#LightOSM.osm_network_from_place_name","page":"Download OpenStreetMap Network","title":"LightOSM.osm_network_from_place_name","text":"osm_network_from_place_name(;place_name::String,\n                            network_type::Symbol=:drive,\n                            metadata::Bool=false,\n                            download_format::Symbol=:json\n                            )::String\n\nDownloads an OpenStreetMap network using any place name string.\n\nArguments\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:json: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap network data response string.\n\n\n\n\n\n","category":"function"},{"location":"download_network/#LightOSM.osm_network_from_point","page":"Download OpenStreetMap Network","title":"LightOSM.osm_network_from_point","text":"osm_network_from_point(;point::GeoLocation,\n                       radius::Number,\n                       network_type::Symbol=:drive,\n                       metadata::Bool=false,\n                       download_format::Symbol=:json\n                       )::String\n\nDownloads an OpenStreetMap network using bounding box coordinates calculated from a centroid point and radius (km).\n\nArguments\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:json: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap network data response string.\n\n\n\n\n\n","category":"function"},{"location":"download_network/#LightOSM.osm_network_from_bbox","page":"Download OpenStreetMap Network","title":"LightOSM.osm_network_from_bbox","text":"osm_network_from_bbox(;minlat::AbstractFloat,\n                      minlon::AbstractFloat,\n                      maxlat::AbstractFloat,\n                      maxlon::AbstractFloat,\n                      network_type::Symbol=:drive,\n                      metadata::Bool=false,\n                      download_format::Symbol=:json\n                      )::String\n\nDownloads an OpenStreetMap network using bounding box coordinates.\n\nArguments\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:json: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap network data response string.\n\n\n\n\n\n","category":"function"},{"location":"download_network/#LightOSM.osm_network_from_polygon","page":"Download OpenStreetMap Network","title":"LightOSM.osm_network_from_polygon","text":"osm_network_from_polygon(;polygon::AbstractVector,\n                         network_type::Symbol=:drive,\n                         metadata::Bool=false,\n                         download_format::Symbol=:json\n                         )::String\n\nDownloads an OpenStreetMap network using a polygon.\n\nArguments\n\npolygon::AbstractVector: Vector of longitude-latitude pairs.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:json: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap network data response string.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#Shortest-Path","page":"Shortest Path","title":"Shortest Path","text":"","category":"section"},{"location":"shortest_path/","page":"Shortest Path","title":"Shortest Path","text":"shortest_path\nLightOSM.astar\nLightOSM.dijkstra\nshortest_path_from_dijkstra_state\nset_dijkstra_state!\nLightOSM.restriction_cost_adjustment\nLightOSM.distance_heuristic\nLightOSM.time_heuristic\nweights_from_path\ntotal_path_weight\npath_from_parents","category":"page"},{"location":"shortest_path/#LightOSM.shortest_path","page":"Shortest Path","title":"LightOSM.shortest_path","text":"shortest_path([PathAlgorithm,]\n              g::OSMGraph,\n              origin::Union{Integer,Node},\n              destination::Union{Integer,Node},\n              [weights::AbstractMatrix=g.weights;\n              cost_adjustment::Function=(u, v, parents) -> 0.0)\n\nCalculates the shortest path between two OpenStreetMap node ids.\n\nArguments\n\nPathAlgorithm: Path finding algorithm, choose either Dijkstra or AStar, defaults to Dijkstra.\ng::OSMGraph: Graph container.\norigin::Union{Integer,Node}: Origin OpenStreetMap node or node id.\ndestination::Union{Integer,Node},: Destination OpenStreetMap node or node id.\nweights: Optional matrix of node to node edge weights, defaults to g.weights. If a custom weights matrix   is being used with algorithm set to :astar, make sure that a correct heuristic is being used.\ncost_adjustment::Function=(u, ): Option to pass in a function to adjust the cost between each pair   of vetices u and v, normally the cost is just the weight between u and v, cost_adjustment takes   in 3 arguments; u, v and parents to apply an additive cost to the default weight. Defaults no adjustment.   Use restriction_cost_adjustment to consider turn restrictions.\nheuristic::Function=distance_heuristic(g): Use custom heuristic with the AStar algorithm only. Defaults to a    function h(u, v) -> haversine(u, v), i.e. returns the haversine distances between u is the current   node and v is the neighbouring node. If g.weight_type is :time or :lane_efficiency use time_heuristic(g)   instead.\n\nReturn\n\nUnion{Nothing,Vector{T}}: Array of OpenStreetMap node ids making up the shortest path.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#LightOSM.astar","page":"Shortest Path","title":"LightOSM.astar","text":"astar(g::AbstractGraph{U},\n      weights::AbstractMatrix{T},\n      src::W,\n      goal::W;\n      heuristic::Function=(u, v) ->  0.0,\n      cost_adjustment::Function=(u, v, parents) -> 0.0\n      ) where {T <: Real, U <: Integer, W <: Integer}\n\nA* shortest path algorithm. Implemented with a min heap. Using a min heap is faster than using  a priority queue given the sparse nature of OpenStreetMap data, i.e. vertices far outnumber edges.\n\nCompared to jl, this version improves runtime, memory usage, has a flexible heuristic  function, and accounts for OpenStreetMap turn restrictions through the cost_adjustment function.\n\nNote: A heuristic that does not accurately estimate the remaining cost to goal (i.e. overestimating heuristic) will result in a non-optimal path (i.e. not the shortest), dijkstra on the other hand  guarantees the optimal path as the heuristic cost is zero.\n\nArguments\n\ng::AbstractGraph{U}: Graphs abstract graph object.\nweights::AbstractMatrix{T}: Edge weights matrix.\nsrc::W: Source vertex.\ngoal::W: Goal vertex.\nheuristic::Function=h(u, v) =  0.0: Heuristic cost function, takes a source and target vertex, default is 0.\ncost_adjustment:::Function=r(u, v, parents) = 0.0: Optional cost adjustment function for use cases such as turn restrictions, takes a source and target vertex, defaults to 0.\n\nReturn\n\nUnion{Nothing,Vector{U}}: Array veritces represeting shortest path between src to goal.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#LightOSM.dijkstra","page":"Shortest Path","title":"LightOSM.dijkstra","text":"dijkstra(g::AbstractGraph{U},\n         weights::AbstractMatrix{T},\n         src::W,\n         goal::W;\n         cost_adjustment::Function=(u, v, parents) -> 0.0\n         ) where {T <: Real, U <: Integer}\n\nDijkstra's shortest path algorithm with an early exit condition, is the same as astar with heuristic cost as 0.\n\nArguments\n\ng::AbstractGraph{U}: Graphs abstract graph object.\nweights::AbstractMatrix{T}: Edge weights matrix.\nsrc::W: Source vertex.\ngoal::W: Goal vertex.\ncost_adjustment:::Function=r(u, v, parents) = 0.0: Optional cost adjustment function for use cases such as turn restrictions, takes a source and target vertex, defaults to 0.\n\nReturn\n\nUnion{Nothing,Vector{U}}: Array veritces represeting shortest path between src to goal.\n\n\n\n\n\ndijkstra(g::AbstractGraph{U},\n         weights::AbstractMatrix{T},\n         src::W;\n         cost_adjustment::Function=(u, v, parents) -> 0.0\n         ) where {T <: Real, U <: Integer, W <: Integer}\n\nDijkstra's shortest path algorithm, implemented with a min heap. Using a min heap is faster than using  a priority queue given the sparse nature of OpenStreetMap data, i.e. vertices far outnumber edges.\n\nThis dispatch returns full set of parents or the dijkstra state given a source vertex, i.e. without and early exit condition of goal.\n\nArguments\n\ng::AbstractGraph{U}: Graphs abstract graph object.\nweights::AbstractMatrix{T}: Edge weights matrix.\nsrc::W: Source vertex.\ncost_adjustment:::Function=r(u, v, parents) = 0.0: Optional cost adjustment function for use cases such as turn restrictions, takes a source and target vertex, defaults to 0.\n\nReturn\n\nVector{U}: Array parent veritces from which the shortest path can be extracted.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#LightOSM.shortest_path_from_dijkstra_state","page":"Shortest Path","title":"LightOSM.shortest_path_from_dijkstra_state","text":"shortest_path_from_dijkstra_state(g::OSMGraph, origin::Integer, destination::Integer)\n\nExtract shortest path from precomputed dijkstra state, from origin to detination node id.\n\nNote, function will raise UndefRefError: access to undefined reference if the dijkstra state of the origin node is not precomputed.\n\nArguments\n\ng::OSMGraph: Graph container.\norigin::Integer: Origin OpenStreetMap node or node id.\ndestination::Integer: Destination OpenStreetMap node or node id.\n\nReturn\n\nUnion{Nothing,Vector{T}}: Array of OpenStreetMap node ids making up the shortest path.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#LightOSM.set_dijkstra_state!","page":"Shortest Path","title":"LightOSM.set_dijkstra_state!","text":"set_dijkstra_state!(g::OSMGraph, src::Union{Integer,Vecotr{<:Integer}, weights::AbstractMatrix; cost_adjustment::Function=(u, v, parents) -> 0.0)\n\nCompute and set the dijkstra parent states for one or multiple src vertices. Threads are used for multiple srcs. Note, computing dijkstra states for all vertices is a O(V² + ElogV) operation, use on large graphs with caution.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#LightOSM.restriction_cost_adjustment","page":"Shortest Path","title":"LightOSM.restriction_cost_adjustment","text":"restriction_cost_adjustment(g::OSMGraph)\n\nReturns the cost adjustment function (user in dijkstra and astar) for restrictions. The return function  takes 3 arguments, u being the current node, v being the neighbour node, parents being the array  of parent dijkstra states. By default g.indexed_restrictions is used to check whether the path from  u to v is restricted given all previous nodes in parents.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#LightOSM.distance_heuristic","page":"Shortest Path","title":"LightOSM.distance_heuristic","text":"distance_heuristic(g::OSMGraph)\n\nReturns the heuristic function used in astar shortest path calculation, should be used with a graph with weight_type=:distance. The heuristic function takes in 2 arguments, u being the current node and v  being the neighbour node, and returns the haversine distance between them.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#LightOSM.time_heuristic","page":"Shortest Path","title":"LightOSM.time_heuristic","text":"time_heuristic(g::OSMGraph)\n\nReturns the heuristic function used in astar shortest path calculation, should be used with a graph with weight_type=:time or weight_type=:lane_efficiency. The heuristic function takes in 2 arguments, u  being the current node and v being the neighbour node, and returns the estimated travel time between them.  Calculated by dividing the harversine distance by a fixed maxspeed of 100. Remember to achieve an optimal path, it is important to pick an underestimating heuristic that best estimates the cost remaining to the goal, hence we pick the largest maxspeed across all ways.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#LightOSM.weights_from_path","page":"Shortest Path","title":"LightOSM.weights_from_path","text":"weights_from_path(g::OSMGraph{U,T,W}, path::Vector{T}; weights=g.weights)::Vector{W} where {U <: Integer,T <: Integer,W <: Real}\n\nExtracts edge weights from a path using the weight matrix stored in g.weights unless a different matrix is passed to the weights kwarg.\n\nArguments\n\ng::OSMGraph: Graph container.\npath::Vector{T}: Array of OpenStreetMap node ids.\nweights=g.weights: the matrix that the edge weights are extracted from. Defaults to g.weights.\n\nReturn\n\nVector{W}: Array of edge weights, distances are in km, time is in hours.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#LightOSM.total_path_weight","page":"Shortest Path","title":"LightOSM.total_path_weight","text":"total_path_weight(g::OSMGraph{U,T,W}, path::Vector{T}; weights=g.weights)::W where {U <: Integer,T <: Integer,W <: Real}\n\nExtract total edge weight along a path.\n\nArguments\n\ng::OSMGraph: Graph container.\npath::Vector{T}: Array of OpenStreetMap node ids.\nweights=g.weights: the matrix that the edge weights are extracted from. Defaults to g.weights.\n\nReturn\n\nsum::W: Total path edge weight, distances are in km, time is in hours.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#LightOSM.path_from_parents","page":"Shortest Path","title":"LightOSM.path_from_parents","text":"path_from_parents(parents::Vector{<:U}, goal::V)::Vector{U} where {U <: Integer, V <: Integer}\n\nExtracts shortest path given dijkstra parents of a given source.\n\nArguments\n\nparents::Vector{U}: Array of dijkstra parent states.\ngoal::V: Goal vertex.\n\nReturn\n\nUnion{Nothing,Vector{U}}: Array veritces represeting shortest path to goal.\n\n\n\n\n\npath_from_parents(parents::Vector{<:U}, goal::V, path_length::N)::Vector{U} where {U <: Integer, V <: Integer, N <: Integer}\n\nExtracts shortest path given dijkstra parents of a given source, providing path_length allows preallocation of the array and avoids the need to reverse the path.\n\nArguments\n\nparents::Vector{U}: Array of dijkstra parent states.\ngoal::V: Goal vertex.\npath_kength::N: Known length of the return path, allows preallocation of final path array.\n\nReturn\n\nUnion{Nothing,Vector{U}}: Array veritces represeting shortest path to goal.\n\n\n\n\n\n","category":"function"},{"location":"#LightOSM.jl","page":"Home","title":"LightOSM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LightOSM.jl is Julia package for downloading and analysing geospatial data from OpenStreetMap APIs (Nominatim and Overpass), such as nodes, ways, relations and building polygons.","category":"page"},{"location":"#Interface","page":"Home","title":"Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"types.md\",\n    \"download_network.md\",\n    \"create_graph.md\",\n    \"shortest_path.md\",\n    \"nearest_node.md\",\n    \"download_buildings.md\",\n    \"create_buildings.md\",\n    \"geolocation.md\"\n    \"graph_utilities.md\"\n]","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LightOSM.jl is inspired by the Python package OSMnx for its interface and Overpass query logic. Graph analysis algorithms (connected components and shortest path) are based on LightGraphs.jl implementation, but adapted to account for turn restrictions and improve runtime performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Another honourable mention goes to an existing Julia package OpenStreetMapX.jl as many learnings were taken to improve parsing of raw OpenStreetMap data.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Search, download and save OpenSteetMap data in .osm, .xml or .json, using a place name, centroid point or bounding box\nParse OpenStreetMap transport network data such as motorway, cycleway or walkway\nParse OpenStreetMap buildings data into a format consistent with the GeoJSON standard, allowing for visualisation with libraries such as deck.gl\nCalculate shortest path between two nodes using the Dijkstra or A* algorithm (based on LightGraphs.jl, but adapted for better performance and use cases such as turn resrictions)\nFind nearest nodes from a query point using a K-D Tree data structure (implemented using NearestNeighbors.jl)","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A comprehensive tutorial can be found found here.","category":"page"},{"location":"#Using-OSMGraphs-in-Unit-Tests","page":"Home","title":"Using OSMGraphs in Unit Tests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"testing_use.md\"]","category":"page"},{"location":"#Benchmarks","page":"Home","title":"Benchmarks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Benchmark comparison for shortest path algorithms can be found here.","category":"page"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"OSMGraph\nGeoLocation\nNode\nWay\nRestriction\nBuilding\nPathAlgorithm","category":"page"},{"location":"types/#LightOSM.OSMGraph","page":"Types","title":"LightOSM.OSMGraph","text":"Container for storing OpenStreetMap node, way, relation and graph related obejcts.\n\nU <: Integer,T <: Integer,W <: Real\n\nnodes::Dict{T,Node{T}}: Mapping of node ids to node objects.\nnode_coordinates::Vector{Vector{W}}: Vector of node coordinates [[lat, lon]...], indexed by graph vertices.\nways::Dict{T,Way{T}}: Mapping of way ids to way objects. Previously called highways.\nnode_to_index::OrderedDict{T,U}: Mapping of node ids to graph vertices.\nindex_to_node::OrderedDict{U,T}: Mapping of graph vertices to node ids.\nnode_to_way::Dict{T,Vector{T}}: Mapping of node ids to vector of way ids. Previously called node_to_highway.\nedge_to_way::Dict{Vector{T},T}: Mapping of edges (adjacent node pairs) to way ids. Previously called edge_to_highway.\nrestrictions::Dict{T,Restriction{T}}: Mapping of relation ids to restriction objects.\nindexed_restrictions::Union{DefaultDict{U,Vector{MutableLinkedList{U}}},Nothing}: Mapping of via node ids to ordered sequences of restricted node ids.\ngraph::Union{AbstractGraph,Nothing}: Either DiGraph, StaticDiGraph, SimpleWeightedDiGraph or MetaDiGraph.\nweights::Union{SparseMatrixCSC{W,U},Nothing}: Sparse adjacency matrix (weights between graph vertices), either :distance (km), :time (hours) or :lane_efficiency (time scaled by number of lanes).\ndijkstra_states::Vector{Vector{U}}: Vector of dijkstra parent states indexed by source vertices, used to retrieve shortest path from source vertex to any other vertex.\nkdtree::Union{KDTree,Nothing}: KDTree used to calculate nearest nodes.\nweight_type::Union{Symbol,Nothing}: Either :distance, :time or :lane_efficiency.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightOSM.GeoLocation","page":"Types","title":"LightOSM.GeoLocation","text":"Representation of a geospatial coordinates.\n\nlat::Float64: Latitude.\nlon::Float64: Longitude.\nalt::Float64: Altitude.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightOSM.Node","page":"Types","title":"LightOSM.Node","text":"OpenStreetMap node.\n\nT<:Integer\n\nid::T: OpenStreetMap node id.\nnodes::Vector{T}: Node's GeoLocation.\ntags::AbstractDict{String,Any}: Metadata tags.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightOSM.Way","page":"Types","title":"LightOSM.Way","text":"OpenStreetMap way.\n\nT<:Integer\n\nid::T: OpenStreetMap way id.\nnodes::Vector{T}: Ordered list of node ids making up the way.\ntags::AbstractDict{String,Any}: Metadata tags.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightOSM.Restriction","page":"Types","title":"LightOSM.Restriction","text":"OpenStreetMap turn restriction (relation).\n\nT<:Integer\n\nid::T: OpenStreetMap relation id.\ntype::String: Either a via_way or via_node turn restriction.\ntags::AbstractDict{String,Any}: Metadata tags.\nfrom_way::T: Incoming way id to the turn restriction.\nto_way::T: Outgoing way id to the turn restriction.\nvia_node::Union{T,Nothing}: Node id at the centre of the turn restriction.\nvia_way::Union{Vector{T},Nothing}: Way id at the centre of the turn restriction.\nis_exclusion::Bool: Turn restrictions such as no_left_turn, no_right_turn or no_u_turn.\nis_exclusive::Bool: Turn restrictions such as striaght_on_only, left_turn_only, right_turn_only.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightOSM.Building","page":"Types","title":"LightOSM.Building","text":"OpenStreetMap building.\n\nT<:Integer\n\nid::T: OpenStreetMap building way id a simple polygon, relation id if a multi-polygon\nis_relation::Bool: True if building is a a multi-polygon / relation.\npolygons::Vector{Polygon{T}}: List of building polygons, first is always the outer ring.\ntags::AbstractDict{String,Any}: Metadata tags.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightOSM.PathAlgorithm","page":"Types","title":"LightOSM.PathAlgorithm","text":"PathAlgorithm.\n\nAbstract type for path finding algorithms, concrete types are:\n\nDijkstra\nAStar\n\n\n\n\n\n","category":"type"}]
}
