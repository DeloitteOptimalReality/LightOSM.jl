var documenterSearchIndex = {"docs":
[{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"OSMGraph\nGeoLocation\nNode\nWay\nRestriction\nBuilding","category":"page"},{"location":"types/#LightOSM.OSMGraph","page":"Types","title":"LightOSM.OSMGraph","text":"Container for storing OpenStreetMap node, way, relation and graph related obejcts.\n\nU <: Integer,T <: Integer,W <: Real\n\nnodes::AbstractDict{T,Node{T}}: Mapping of node ids to node objects.\nnode_coordinates::Vector{Vector{W}}: Vector of node coordinates [[lat, lon]...], indexed by graph vertices.\nhighways::AbstractDict{T,Way{T}}: Mapping of way ids to way objects.\nnode_to_index::AbstractDict{T,U}: Mapping of node ids to graph vertices.\nindex_to_node::AbstractDict{U,T}: Mapping of graph vertices to node ids.\nnode_to_highway::AbstractDict{T,Vector{T}}: Mapping of node ids to vector of way ids.\nedge_to_highway::AbstractDict{Vector{T},T}: Mapping of edges (adjacent node pairs) to way ids.\nrestrictions::AbstractDict{T,Restriction{T}}: Mapping of relation ids to restriction objects.\nindexed_restrictions::Union{AbstractDict{U,Vector{MutableLinkedList{U}}},Nothing}: Mapping of via node ids to ordered sequences of restricted node ids.\ngraph::Union{AbstractGraph,Nothing}: Either DiGraph, StaticDiGraph, SimpleWeightedDiGraph or MetaDiGraph.\nweights::Union{SparseMatrixCSC{W,U},Nothing}: Sparse adjacency matrix (weights between graph vertices), either :distance (km), :time (hours) or :lane_efficiency (time scaled by number of lanes).\ndijkstra_states::Vector{Vector{U}}: Vector of dijkstra parent states indexed by source vertices, used to retrieve shortest path from source vertex to any other vertex.\nkdtree::Union{KDTree,Nothing}: KDTree used to calculate nearest nodes.\nweight_type::Union{Symbol,Nothing}: Either :distance, :time or :lane_efficiency.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightOSM.GeoLocation","page":"Types","title":"LightOSM.GeoLocation","text":"Representation of a geospatial coordinates.\n\nlat::Float64: Latitude.\nlon::Float64: Longitude.\nalt::Float64: Altitude.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightOSM.Node","page":"Types","title":"LightOSM.Node","text":"OpenStreetMap node.\n\nT<:Integer\n\nid::T: OpenStreetMap node id.\nnodes::Vector{T}: Node's GeoLocation.\ntags::AbstractDict{String,Any}: Metadata tags.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightOSM.Way","page":"Types","title":"LightOSM.Way","text":"OpenStreetMap way.\n\nT<:Integer\n\nid::T: OpenStreetMap way id.\nnodes::Vector{T}: Ordered list of node ids making up the way.\ntags::AbstractDict{String,Any}: Metadata tags.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightOSM.Restriction","page":"Types","title":"LightOSM.Restriction","text":"OpenStreetMap turn restriction (relation).\n\nT<:Integer\n\nid::T: OpenStreetMap relation id.\ntype::String: Either a via_way or via_node turn restriction.\ntags::AbstractDict{String,Any}: Metadata tags.\nfrom_way::T: Incoming way id to the turn restriction.\nto_way::T: Outgoing way id to the turn restriction.\nvia_node::Union{T,Nothing}: Node id at the centre of the turn restriction.\nvia_way::Union{Vector{T},Nothing}: Way id at the centre of the turn restriction.\nis_exclusion::Bool: Turn restrictions such as no_left_turn, no_right_turn or no_u_turn.\nis_exclusive::Bool: Turn restrictions such as striaght_on_only, left_turn_only, right_turn_only.\n\n\n\n\n\n","category":"type"},{"location":"types/#LightOSM.Building","page":"Types","title":"LightOSM.Building","text":"OpenStreetMap building.\n\nT<:Integer\n\nid::T: OpenStreetMap building way id a simple polygon, relation id if a multi-polygon\nis_relation::Bool: True if building is a a multi-polygon / relation.\npolygons::Vector{Polygon{T}}: List of building polygons, first is always the outer ring.\ntags::AbstractDict{String,Any}: Metadata tags.\n\n\n\n\n\n","category":"type"},{"location":"download_buildings/#Download-OpenStreetMap-Buildings","page":"Download OpenStreetMap Buildings","title":"Download OpenStreetMap Buildings","text":"","category":"section"},{"location":"download_buildings/","page":"Download OpenStreetMap Buildings","title":"Download OpenStreetMap Buildings","text":"download_osm_buildings\nLightOSM.osm_buildings_from_place_name\nLightOSM.osm_buildings_from_point\nLightOSM.osm_buildings_from_bbox","category":"page"},{"location":"download_buildings/#LightOSM.download_osm_buildings","page":"Download OpenStreetMap Buildings","title":"LightOSM.download_osm_buildings","text":"download_osm_buildings(download_method::Symbol;\n                       metadata::Bool=false,\n                       download_format::Symbol=:osm,\n                       save_to_file_location::Union{String,Nothing}=nothing,\n                       download_kwargs...\n                       )::Union{XMLDocument,Dict{String,Any}}\n\nDownloads OpenStreetMap buildings data by querying with a place name, bounding box, or centroid point.\n\nArguments\n\ndownload_method::Symbol: Download method, choose from :place_name, :bbox or :point.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\nsave_to_file_location::Union{String,Nothing}=nothing: Specify a file location to save downloaded data to disk.\n\nRequired Download Kwargs\n\ndownload_method=:place_name\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\n\ndownload_method=:bbox\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\n\ndownload_method=:point\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\n\nReturn\n\nUnion{XMLDocument,Dict{String,Any}}: OpenStreetMap buildings data parsed as either XML or Dictionary object depending on the download method.\n\n\n\n\n\n","category":"function"},{"location":"download_buildings/#LightOSM.osm_buildings_from_place_name","page":"Download OpenStreetMap Buildings","title":"LightOSM.osm_buildings_from_place_name","text":"osm_network_from_place_name(;place_name::String,\n                            metadata::Bool=false,\n                            download_format::Symbol=:osm\n                            )::String\n\nDownloads OpenStreetMap buildings using any place name string.\n\nArguments\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap buildings data response string.\n\n\n\n\n\n","category":"function"},{"location":"download_buildings/#LightOSM.osm_buildings_from_point","page":"Download OpenStreetMap Buildings","title":"LightOSM.osm_buildings_from_point","text":"osm_network_from_point(;point::GeoLocation,\n                       radius::Number,\n                       metadata::Bool=false,\n                       download_format::Symbol=:osm\n                       )::String\n\nDownloads OpenStreetMap buildings using bounding box coordinates calculated from a centroid point and radius (km).\n\nArguments\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap buildings data response string.\n\n\n\n\n\n","category":"function"},{"location":"download_buildings/#LightOSM.osm_buildings_from_bbox","page":"Download OpenStreetMap Buildings","title":"LightOSM.osm_buildings_from_bbox","text":"osm_network_from_bbox(;minlat::AbstractFloat,\n                      minlon::AbstractFloat,\n                      maxlat::AbstractFloat,\n                      maxlon::AbstractFloat,\n                      metadata::Bool=false,\n                      download_format::Symbol=:osm\n                      )::String\n\nDownloads OpenStreetMap buildings using bounding box coordinates.\n\nArguments\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap buildings data response string.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#Shortest-Path","page":"Shortest Path","title":"Shortest Path","text":"","category":"section"},{"location":"shortest_path/","page":"Shortest Path","title":"Shortest Path","text":"shortest_path\nweights_from_path\nLightOSM.astar\nLightOSM.dijkstra","category":"page"},{"location":"shortest_path/#LightOSM.shortest_path","page":"Shortest Path","title":"LightOSM.shortest_path","text":"shortest_path(g::OSMGraph,\n              origin::U,\n              destination::U;\n              algorithm::Symbol=:dijkstra,\n              save_dijkstra_state::Bool=false,\n              heuristic::Union{Function,Nothing}=nothing\n              )::Vector{U} where {U <: Integer}\n\nCalculates the shortest path between two OpenStreetMap node ids.\n\nArguments\n\ng::OSMGraph: Graph container.\norigin::U: Origin OpenStreetMap node id.\ndestination::U: Destination OpenStreetMap node id.\nalgorithm::Symbol=:dijkstra: Shortest path algorithm, either. :dijkstra or :astar.\nsave_dijkstra_state::Bool=false: Option to cache dijkstra parent states from a single source.\nheuristic::Union{Function,Nothing}=nothing: Option to use custom astar heuristic, default haversine distance will be used if left blank.\n\nReturn\n\nVector{U}: Array of OpenStreetMap node ids making up the shortest path.\n\n\n\n\n\nCalculates the shortest path between two OpenStreetMap node objects.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#LightOSM.weights_from_path","page":"Shortest Path","title":"LightOSM.weights_from_path","text":"weights_from_path(g::OSMGraph{U,T,W}, path::Vector{T})::Vector{W} where {U <: Integer,T <: Integer,W <: Real}\n\nExtracts edge weights from a path using g.weights.\n\nArguments\n\ng::OSMGraph: Graph container.\npath::Vector{T}: Array of OpenStreetMap node ids.\n\nReturn\n\nVector{W}: Array of edge weights, distances are in km, time is in hours.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#LightOSM.astar","page":"Shortest Path","title":"LightOSM.astar","text":"astar(g::AbstractGraph{U},\n      src::W;\n      goal::Union{W,Nothing}=nothing,\n      distmx::AbstractMatrix{T}=weights(g),\n      restrictions::Union{AbstractDict{V,Vector{MutableLinkedList{V}}},Nothing}=nothing,\n      heuristic::Function=h(u, v) =  0.0,\n      )::Vector{U} where {T <: Real,U <: Integer,V <: Integer,W <: Integer}\n\nA* shortest path algorithm taken and adapted from LightGraphs.jl. This version improves runtime  speed, memory usage, has a more flexible heruistic function, and accounts for OpenStreetMap  turn restrictions.\n\nArguments\n\ng::AbstractGraph{U}: LightGraphs abstract graph object.\nsrc::W: Source vertex.\ngoal::Union{W,Nothing}=nothing: Optional target vertex as a break condition.\ndistmx::AbstractMatrix{T}=weights(g): Optional weight matrix.\nrestrictions::Union{AbstractDict{V,Vector{MutableLinkedList{V}}},Nothing}=nothing: Optional \n\ndictionary of restrictions, keyed by vertex, each restriction is a linked list of vertices,  any path containing the entire list will have an infinite cost assigned to it.\n\nheuristic::Function=h(u, v) =  0.0: Heuristic cost function, takes a source and target vertex, default is 0.\n\nReturn\n\nVector{U}: Array parent veritces from which the shortest path can be extracted.\n\n\n\n\n\n","category":"function"},{"location":"shortest_path/#LightOSM.dijkstra","page":"Shortest Path","title":"LightOSM.dijkstra","text":"Dijkstra shortest path algorithm, same as A* but without a heuristic cost function.\n\n\n\n\n\n","category":"function"},{"location":"create_graph/#Create-[OSMGraph](@ref)-Object","page":"Create OSMGraph Object","title":"Create OSMGraph Object","text":"","category":"section"},{"location":"create_graph/","page":"Create OSMGraph Object","title":"Create OSMGraph Object","text":"graph_from_object\ngraph_from_download\ngraph_from_file","category":"page"},{"location":"create_graph/#LightOSM.graph_from_object","page":"Create OSMGraph Object","title":"LightOSM.graph_from_object","text":"graph_from_object(osm_data_object::Union{XMLDocument,Dict};\n                  network_type::Symbol=:drive,\n                  weight_type::Symbol=:time,\n                  graph_type::Symbol=:static,\n                  precompute_dijkstra_states::Bool=false,\n                  largest_connected_component::Bool=true\n                  )::OSMGraph\n\nCreates an OSMGraph object from download OpenStreetMap network data, use with download_osm_network.\n\nArguments\n\nosm_data_object::Symbol: OpenStreetMap network data parsed as either XML or Dictionary object depending on the download method.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail, must match the network type used to download osm_data_object.\nweight_type::Symbol=:time: Weight type for graph edges, pick from :distance (km), :time (hours), :lane_efficiency (time scaled by number of lanes). \ngraph_type::Symbol=:static: Type of LightGraphs.AbstractGraph, pick from :static (StaticDiGraph), :light (DiGraph), :simple_weighted (SimpleWeightedDiGraph), :meta (MetaDiGraph).\nprecompute_dijkstra_states::Bool=false: Set true to precompute dijkstra parent states for every source node in the graph, NOTE this may take a while and may not be possible for graphs with large amount of nodes due to memory limits.\nlargest_connected_component::Bool=true: Set true to keep only the largest connected components in the network.\n\nReturn\n\nOSMGraph: Container for storing OpenStreetMap node, way, relation and graph related obejcts.\n\n\n\n\n\n","category":"function"},{"location":"create_graph/#LightOSM.graph_from_download","page":"Create OSMGraph Object","title":"LightOSM.graph_from_download","text":"graph_from_download(download_method::Symbol;\n                    network_type::Symbol=:drive,\n                    metadata::Bool=false,\n                    download_format::Symbol=:osm,\n                    save_to_file_location::Union{String,Nothing}=nothing,\n                    weight_type::Symbol=:time,\n                    graph_type::Symbol=:static,\n                    precompute_dijkstra_states::Bool=false,\n                    largest_connected_component::Bool=true,\n                    download_kwargs...\n                    )::OSMGraph\n\nDownloads OpenStreetMap network data and creates an OSMGraph object.\n\nArguments\n\ndownload_method::Symbol: Download method, choose from :place_name, :bbox or :point.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\nsave_to_file_location::Union{String,Nothing}=nothing: Specify a file location to save downloaded data to disk.\nweight_type::Symbol=:time: Weight type for graph edges, pick from :distance (km), :time (hours), :lane_efficiency (time scaled by number of lanes). \ngraph_type::Symbol=:static: Type of LightGraphs.AbstractGraph, pick from :static (StaticDiGraph), :light (DiGraph), :simple_weighted (SimpleWeightedDiGraph), :meta (MetaDiGraph).\nprecompute_dijkstra_states::Bool=false: Set true to precompute dijkstra parent states for every source node in the graph, NOTE this may take a while and may not be possible for graphs with large amount of nodes due to memory limits.\nlargest_connected_component::Bool=true: Set true to keep only the largest connected components in the network.\n\nRequired Kwargs for each Download Method\n\ndownload_method=:place_name\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\n\ndownload_method=:bbox\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\n\ndownload_method=:point\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\n\ndownload_method=:polygon\n\npolygon::AbstractVector: Vector of longitude-latitude pairs.\n\nNetwork Types\n\n:drive: Motorways excluding private and service ways.\n:drive_service: Motorways including private and service ways.\n:walk: Walkways only.\n:bike: Cycleways only.\n:all: All motorways, walkways and cycleways excluding private ways.\n:all_private: All motorways, walkways and cycleways including private ways.\n:none: No network filters.\n:rail: Railways excluding proposed and platform.\n\nReturn\n\nOSMGraph: Container for storing OpenStreetMap node, way, relation and graph related obejcts.\n\n\n\n\n\n","category":"function"},{"location":"create_graph/#LightOSM.graph_from_file","page":"Create OSMGraph Object","title":"LightOSM.graph_from_file","text":"graph_from_object(file_path::String;\n                  network_type::Symbol=:drive,\n                  weight_type::Symbol=:time,\n                  graph_type::Symbol=:static,\n                  precompute_dijkstra_states::Bool=false,\n                  largest_connected_component::Bool=true\n                  )::OSMGraph\n\nCreates an OSMGraph object from a downloaded OpenStreetMap network data file, the extention must be either .json, .osm or .xml.\n\nArguments\n\nfile_path::String: OpenStreetMap network data file location.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail, must match the network type used to download osm_data_object.\nweight_type::Symbol=:time: Weight type for graph edges, pick from :distance (km), :time (hours), :lane_efficiency (time scaled by number of lanes). \ngraph_type::Symbol=:static: Type of LightGraphs.AbstractGraph, pick from :static (StaticDiGraph), :light (DiGraph), :simple_weighted (SimpleWeightedDiGraph), :meta (MetaDiGraph).\nprecompute_dijkstra_states::Bool=false: Set true to precompute dijkstra parent states for every source node in the graph, NOTE this may take a while and may not be possible for graphs with large amount of nodes due to memory limits.\nlargest_connected_component::Bool=true: Set true to keep only the largest connected components in the network.\n\nReturn\n\nOSMGraph: Container for storing OpenStreetMap node, way, relation and graph related obejcts.\n\n\n\n\n\n","category":"function"},{"location":"create_buildings/#Create-[Building](@ref)-Objects","page":"Create Building Objects","title":"Create Building Objects","text":"","category":"section"},{"location":"create_buildings/","page":"Create Building Objects","title":"Create Building Objects","text":"buildings_from_object\nbuildings_from_download\nbuildings_from_file","category":"page"},{"location":"create_buildings/#LightOSM.buildings_from_object","page":"Create Building Objects","title":"LightOSM.buildings_from_object","text":"buildings_from_object(buildings_xml_object::XMLDocument)::Dict{Integer,Building}\n\nCreates Building objects from data downloaded with download_osm_buildings.\n\nArguments\n\nbuildings_xml_object::XMLDocument: Buildings data downloaded in :xml or :osm format.\n\nReturn\n\nDict{Integer,Building}: Mapping from building relation/way ids to Building objects.\n\n\n\n\n\nbuildings_from_object(buildings_json_object::AbstractDict)::Dict{Integer,Building}\n\nCreates Building objects from data downloaded with download_osm_buildings.\n\nArguments\n\nbuildings_json_object::AbstractDict: Buildings data downloaded in :json format.\n\nReturn\n\nDict{Integer,Building}: Mapping from building relation/way ids to Building objects.\n\n\n\n\n\n","category":"function"},{"location":"create_buildings/#LightOSM.buildings_from_download","page":"Create Building Objects","title":"LightOSM.buildings_from_download","text":"buildings_from_download(download_method::Symbol;\n                        metadata::Bool=false,\n                        download_format::Symbol=:osm,\n                        save_to_file_location::Union{String,Nothing}=nothing,\n                        download_kwargs...\n                        )::Dict{Integer,Building}\n\nDownloads and Creates Building objects from OpenStreetMap APIs.\n\nArguments\n\ndownload_method::Symbol: Download method, choose from :place_name, :bbox or :point.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\nsave_to_file_location::Union{String,Nothing}=nothing: Specify a file location to save downloaded data to disk.\n\nRequired Download Kwargs\n\ndownload_method=:place_name\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\n\ndownload_method=:bbox\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\n\ndownload_method=:point\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\n\nReturn\n\nDict{Integer,Building}: Mapping from building relation/way ids to Building objects.\n\n\n\n\n\n","category":"function"},{"location":"create_buildings/#LightOSM.buildings_from_file","page":"Create Building Objects","title":"LightOSM.buildings_from_file","text":"buildings_from_file(file_path::String)::Dict{Integer,Building}\n\nCreates Building objects from OpenStreetMap data file (either :osm, :xml or :json format).\n\nArguments\n\nfile_path::String: Path to OpenStreetMap data file.\n\nReturn\n\nDict{Integer,Building}: Mapping from building relation/way ids to Building objects.\n\n\n\n\n\n","category":"function"},{"location":"download_network/#Download-OpenStreetMap-Network","page":"Download OpenStreetMap Network","title":"Download OpenStreetMap Network","text":"","category":"section"},{"location":"download_network/","page":"Download OpenStreetMap Network","title":"Download OpenStreetMap Network","text":"download_osm_network\nLightOSM.osm_network_from_place_name\nLightOSM.osm_network_from_point\nLightOSM.osm_network_from_bbox\nLightOSM.osm_network_from_polygon","category":"page"},{"location":"download_network/#LightOSM.download_osm_network","page":"Download OpenStreetMap Network","title":"LightOSM.download_osm_network","text":"download_osm_network(download_method::Symbol;\n                     network_type::Symbol=:drive,\n                     metadata::Bool=false,\n                     download_format::Symbol=:osm,\n                     save_to_file_location::Union{String,Nothing}=nothing,\n                     download_kwargs...\n                     )::Union{XMLDocument,Dict{String,Any}}\n\nDownloads an OpenStreetMap network by querying with a place name, bounding box, or centroid point.\n\nArguments\n\ndownload_method::Symbol: Download method, choose from :place_name, :bbox or :point.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\nsave_to_file_location::Union{String,Nothing}=nothing: Specify a file location to save downloaded data to disk.\n\nRequired Kwargs for each Download Method\n\ndownload_method=:place_name\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\n\ndownload_method=:bbox\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\n\ndownload_method=:point\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\n\ndownload_method=:polygon\n\npolygon::AbstractVector: Vector of longitude-latitude pairs.\n\nNetwork Types\n\n:drive: Motorways excluding private and service ways.\n:drive_service: Motorways including private and service ways.\n:walk: Walkways only.\n:bike: Cycleways only.\n:all: All motorways, walkways and cycleways excluding private ways.\n:all_private: All motorways, walkways and cycleways including private ways.\n:none: No network filters.\n:rail: Railways excluding proposed and platform.\n\nReturn\n\nUnion{XMLDocument,Dict{String,Any}}: OpenStreetMap network data parsed as either XML or Dictionary object depending on the download method.\n\n\n\n\n\n","category":"function"},{"location":"download_network/#LightOSM.osm_network_from_place_name","page":"Download OpenStreetMap Network","title":"LightOSM.osm_network_from_place_name","text":"osm_network_from_place_name(;place_name::String,\n                            network_type::Symbol=:drive,\n                            metadata::Bool=false,\n                            download_format::Symbol=:osm\n                            )::String\n\nDownloads an OpenStreetMap network using any place name string.\n\nArguments\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap network data response string.\n\n\n\n\n\n","category":"function"},{"location":"download_network/#LightOSM.osm_network_from_point","page":"Download OpenStreetMap Network","title":"LightOSM.osm_network_from_point","text":"osm_network_from_point(;point::GeoLocation,\n                       radius::Number,\n                       network_type::Symbol=:drive,\n                       metadata::Bool=false,\n                       download_format::Symbol=:osm\n                       )::String\n\nDownloads an OpenStreetMap network using bounding box coordinates calculated from a centroid point and radius (km).\n\nArguments\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap network data response string.\n\n\n\n\n\n","category":"function"},{"location":"download_network/#LightOSM.osm_network_from_bbox","page":"Download OpenStreetMap Network","title":"LightOSM.osm_network_from_bbox","text":"osm_network_from_bbox(;minlat::AbstractFloat,\n                      minlon::AbstractFloat,\n                      maxlat::AbstractFloat,\n                      maxlon::AbstractFloat,\n                      network_type::Symbol=:drive,\n                      metadata::Bool=false,\n                      download_format::Symbol=:osm\n                      )::String\n\nDownloads an OpenStreetMap network using bounding box coordinates.\n\nArguments\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap network data response string.\n\n\n\n\n\n","category":"function"},{"location":"download_network/#LightOSM.osm_network_from_polygon","page":"Download OpenStreetMap Network","title":"LightOSM.osm_network_from_polygon","text":"osm_network_from_polygon(;polygon::AbstractVector,\n                         network_type::Symbol=:drive,\n                         metadata::Bool=false,\n                         download_format::Symbol=:osm\n                         )::String\n\nDownloads an OpenStreetMap network using a polygon.\n\nArguments\n\npolygon::AbstractVector: Vector of longitude-latitude pairs.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail.\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:osm: Download format, either :osm, :xml or json.\n\nReturn\n\nString: OpenStreetMap network data response string.\n\n\n\n\n\n","category":"function"},{"location":"geolocation/#[GeoLocation](@ref)-Methods","page":"GeoLocation Methods","title":"GeoLocation Methods","text":"","category":"section"},{"location":"geolocation/","page":"GeoLocation Methods","title":"GeoLocation Methods","text":"distance\nheading\ncalculate_location\nLightOSM.to_cartesian\nLightOSM.bounding_box_from_point","category":"page"},{"location":"geolocation/#LightOSM.distance","page":"GeoLocation Methods","title":"LightOSM.distance","text":"distance(A::Union{Vector{GeoLocation}, GeoLocation, Vector{<:Node}, Node, Vector{<:AbstractFloat}},\n         B::Union{Vector{GeoLocation}, GeoLocation, Vector{<:Node}, Node, Vector{<:AbstractFloat}},\n         type::Symbol=:haversine\n         )\n\nCalculates the distance (km) between two points or two vectors of points.\n\nArguments\n\nA::Union{Vector{GeoLocation}, GeoLocation, Vector{<:Node}, Node, Vector{<:AbstractFloat}}: Vector of origin points.\nB::Union{Vector{GeoLocation}, GeoLocation, Vector{<:Node}, Node, Vector{<:AbstractFloat}}: Vector of destination points.\nmethod::Symbol=:haversine: Either :haversine or :euclidean.\n\nReturn\n\nDistance between origin and destination points in km.\n\n\n\n\n\n","category":"function"},{"location":"geolocation/#LightOSM.calculate_location","page":"GeoLocation Methods","title":"LightOSM.calculate_location","text":"calculate_location(origin::GeoLocation, heading::Number, distance::Number)\ncalculate_location(origin::Node, heading::Number, distance::Number)\ncalculate_location(origin::Vector{GeoLocation}, heading::Vector{<:Number}, distance::Vector{<:Number})\ncalculate_location(origin::Vector{Node}, heading::Vector{<:Number}, distance::Vector{<:Number})\n\nCalculates next location(s) given origin GeoLocation(s) or Node(s), heading(s) (degrees) and distance(s) (km).\n\nLocations are returned as GeoLocations.\n\n\n\n\n\n","category":"function"},{"location":"geolocation/#LightOSM.to_cartesian","page":"GeoLocation Methods","title":"LightOSM.to_cartesian","text":"to_cartesian(lat::T, lon::T, r::T) where {T} \nto_cartesian(location::GeoLocation)\nto_cartesian(locations::Vector{GeoLocation})\n\nConverts a vector of GeoLocations to (x, y, z) cartesian coordinates (based on radius of the Earth).\n\n\n\n\n\n","category":"function"},{"location":"geolocation/#LightOSM.bounding_box_from_point","page":"GeoLocation Methods","title":"LightOSM.bounding_box_from_point","text":"bounding_box_from_point(point::GeoLocation, radius::Number)::NamedTuple\n\nCalculates the coordinates of the bounding box given a centroid point and radius (km).\n\nArguments\n\npoint::GeoLocation: Centroid of the bounding box as an GeoLocation.\nradius::Number: Radius in km of the bounding box (to each corner).\n\nReturn\n\nNamedTuple: Named tuple with attributes minlat, minlon, maxlat, right_lon.\n\n\n\n\n\n","category":"function"},{"location":"#LightOSM.jl","page":"Home","title":"LightOSM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LightOSM.jl is Julia package for downloading and analysing geospatial data from OpenStreetMap APIs (Nominatim and Overpass), such as nodes, ways, relations and building polygons.","category":"page"},{"location":"#Interface","page":"Home","title":"Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"types.md\",\n    \"download_network.md\",\n    \"create_graph.md\",\n    \"shortest_path.md\",\n    \"nearest_node.md\",\n    \"download_buildings.md\",\n    \"create_buildings.md\",\n    \"geolocation.md\"\n]","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LightOSM.jl is inspired by the Python package OSMnx for its interface and Overpass query logic. Graph analysis algorithms (connected components and shortest path) are based on LightGraphs.jl implementation, but adapted to account for turn restrictions and improve runtime performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Another honourable mention goes to an existing Julia package OpenStreetMapX.jl as many learnings were taken to improve parsing of raw OpenStreetMap data.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Search, download and save OpenSteetMap data in .osm, .xml or .json, using a place name, centroid point or bounding box\nParse OpenStreetMap transport network data such as motorway, cycleway or walkway\nParse OpenStreetMap buildings data into a format consistent with the GeoJSON standard, allowing for visualisation with libraries such as deck.gl\nCalculate shortest path between two nodes using the Dijkstra or A* algorithm (based on LightGraphs.jl, but adapted for better performance and use cases such as turn resrictions)\nFind nearest nodes from a query point using a K-D Tree data structure (implemented using NearestNeighbors.jl)","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A comprehensive tutorial can be found found here.","category":"page"},{"location":"#Benchmarks","page":"Home","title":"Benchmarks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Benchmark comparison for shortest path algorithms can be found here.","category":"page"},{"location":"nearest_node/#Nearest-Node","page":"Nearest Node","title":"Nearest Node","text":"","category":"section"},{"location":"nearest_node/","page":"Nearest Node","title":"Nearest Node","text":"nearest_node","category":"page"},{"location":"nearest_node/#LightOSM.nearest_node","page":"Nearest Node","title":"LightOSM.nearest_node","text":"nearest_node(g::OSMGraph,\n             points::Vector{GeoLocation},\n             n_neighbours::Integer=1\n             )::Tuple{Vector{Vector{Integer}}, Vector{Vector{AbstractFloat}}}\n\nFinds nearest nodes from a vector of GeoLocations using a NearestNeighbors.jl KDTree.\n\nArguments\n\ng::OSMGraph: Graph container.\npoints::Vector{GeoLocation}: Vector of query points.\nn_neighbours::Integer: Number of neighbours to query for each point.\n\nReturn\n\nTuple of neighbours and straight line euclidean distances from each point ([[neighbours]...], [[dists]...]).\n\n\n\n\n\nFinds nearest nodes from a vector of node ids, the query node id is excluded from neighbours.\n\n\n\n\n\n","category":"function"}]
}
